%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Eight queens problem
%% We have known that the rules of rook, bishop, queen can be combination of straight, diagonal. And we want to find the rule of each role.


:- module(test,[abduce_consistent_insts/1, chess/3, abduce_consistent_inst/3, eval_chess_label_insts/1, eval_chess/1]).

:- use_module(library(chr)).
:- chr_constraint chess/3. 



%%(x,y,type)
%% x,y : [0,7]    type : [0,2]
%% straight : X1=:=X2;Y1=:=Y2
%% diagonal : X1-X2=:=Y1-Y2;X1-X2=:=Y2-Y1

%% If return false, it conflicts.
%% Can be used to learn type. But there are only three types of chess and three types of rules, so we don't use metagol now.
chess(X1,Y1,0), chess(X2,Y2,_) ==> (X1=:=X2;Y1=:=Y2) | fail.
chess(X1,Y1,1), chess(X2,Y2,_) ==> (X1-X2=:=Y1-Y2;X1-X2=:=Y2-Y1) | fail.
chess(X1,Y1,2), chess(X2,Y2,_) ==> (X1=:=X2;Y1=:=Y2;X1-X2=:=Y1-Y2;X1-X2=:=Y2-Y1) | fail.
%%% s(X) :- chess(4,0,chess_type(0)), chess(6,1,chess_type(0)), chess(1,2,chess_type(0)), chess(3,3,chess_type(1)), chess(5,3,chess_type(1)), chess(3,6,chess_type(X)), chess(7,4,chess_type(2)), chess(0,5,chess_type(2)).
%%% member(X,[0,1,2]),\+s(X).

call_and_undo(X) :- (((call(X)->fail;Y=fail));Y=true),!,(Y->true;fail).
% caller(X,Y) :- ((call(X)->fail;Y=fail));Y=true. %%For concurrent_maplist

%% eval_chess_label_insts([[[[4,0,0], [6,1,0]],true], [[[1, 1, 2], [3, 3, 2]], false], [[[1, 0, 2], [2, 2, 0]], true], [[[2, 1, 1], [0, 2, 0]], true] ]).
eval_chess_label_insts([Parameter|Parameters]):-
    %writeln(Parameter),
    Fun =.. [eval_chess_label|Parameter],
    %writeln(Fun),
    call(Fun),
    eval_chess_label_insts(Parameters).
eval_chess_label_insts([]).

%% eval_chess_label([[4,0,0], [6,1,0], [1,2,0], [3,3,1], [5,3,1], [3,6,1], [7,4,2], [0,5,2]],true).
eval_chess_label(Ex,Label):-
    ground(Ex),
    add_chess(Ex,ChessExs),
    list_to_conj(ChessExs,ChessExsConj),
    (Label -> call_and_undo(ChessExsConj) ; (\+ call_and_undo(ChessExsConj))).
    
%% eval_chess([[4,0,0], [6,1,0], [1,2,0], [3,3,1], [5,3,1], [3,6,1], [7,4,2], [0,5,2]]).
eval_chess(Ex):-
    ground(Ex),
    add_chess(Ex,ChessEx),
    list_to_conj(ChessEx,ChessExConj),
    call(ChessExConj).

% abduce_consistent_insts([[[[1, 1, 2], [3, 3, 2]], [], false], [[[1, 0, 2], [2, 2, 0]], [], true], [[[2, 1, 1], [0, 2, 0]], [], true]]).
% abduce_consistent_insts([[[[4,0,0], [6,1,0], [1,2,0], [3,3,1], [5,3,1], [3,6,X], [7,4,2], [0,5,2]],[X],true] ]).
abduce_consistent_insts([Parameter|Parameters]):-
    Fun =.. [abduce_consistent_inst|Parameter],
    %writeln(Fun),
    call(Fun),
    abduce_consistent_insts(Parameters).
abduce_consistent_insts([]).

abduce_consistent_inst(Exs,Vars,Label):-
    add_member(Vars,X_mem),
    add_chess(Exs,ChessExs),
    list_to_conj(ChessExs,ChessExsConj),
    %writeln(ChessExsConj),
    (Label -> ChessExsConjLabel=(ChessExsConj) ; ChessExsConjLabel= (\+ (ChessExsConj))),
    %writeln(ChessExsConjLabel),
    CallChessExsConjLabel =..[call_and_undo,ChessExsConjLabel],
    append(X_mem,[CallChessExsConjLabel],X),
    list_to_conj(X,Y),
    %writeln(Y),
    call(Y).
    
add_chess([Ex|Exs],[ChessEx|ChessExs]):-
    ChessEx =..[chess|Ex],
    add_chess(Exs,ChessExs).
add_chess([],[]).

% [_1,_2,_3,_4]
add_member([Var|Vars],[Member_re|Member_res]):-
    Member_re =..[member,Var,[0,1,2]],
    add_member(Vars,Member_res).
add_member([],[]).

% convert a list of term to a conjunction
list_to_conj([H], H) :- !.
list_to_conj([H | T], ','(H, Conj)) :-
    list_to_conj(T, Conj).
    
    
%% If return false, it conflicts.
%% Can be used to learn rules.

%%rule(X1,Y1,X2,Y2):- (X1=:=X2;Y1=:=Y2).
%%rule(X1,Y1,X2,Y2):- (X1-X2=:=Y1-Y2;X1-X2=:=Y2-Y1).
%%chess(X1,Y1,0), chess(X2,Y2,_) # passive ==> rule(X1,Y1,X2,Y2) | fail, format('1=', []).



%%chess(X1,Y1,1), chess(X2,Y2,_) # passive ==> (X1-X2=:=Y1-Y2;X1-X2=:=Y2-Y1) | fail, format('2=', []).
%%chess(X1,Y1,2), chess(X2,Y2,_) # passive ==> (X1=:=X2;Y1=:=Y2;X1-X2=:=Y1-Y2;X1-X2=:=Y2-Y1) | fail, format('3=', []).
%%% member(X,[0,1,2]), chess(4,0,0), chess(6,1,X), chess(1,2,0), chess(3,3,1), chess(5,3,1), chess(3,6,1), chess(7,4,2), chess(0,5,2)


%% If return true, it conflicts.
%% Can be used to learn type.
%%chess(X1,Y1,0), chess(X2,Y2,_) # passive ==> (X1=:=X2;Y1=:=Y2) | conflict(1), format('1=', []).
%%chess(X1,Y1,1), chess(X2,Y2,_) # passive ==> (X1-X2=:=Y1-Y2;X1-X2=:=Y2-Y1) | conflict(1), format('2=', []).
%%chess(X1,Y1,2), chess(X2,Y2,_) # passive ==> (X1=:=X2;Y1=:=Y2;X1-X2=:=Y1-Y2;X1-X2=:=Y2-Y1) | conflict(1), format('3=', []).
%%conflict(X),conflict(Y)  <=> conflict(Z), Z is X+Y, format('4=', []).
%%conflict(0) <=> fail, format('6=', []).
%%% member(X,[0,1,2]), chess(4,0,0), chess(6,0,X), chess(1,2,0), chess(3,3,1), chess(5,3,1), chess(3,6,1), chess(7,4,2), chess(0,5,2),conflict(0)






%%chess(X1,Y1,T1), chess(X2,Y2,T2) # passive ==> (X1=:=X2;Y1=:=Y2) | member(T1,[0,1,2]), member(T2,[0,1,2]), (T1=0;T2=0;T1=2;T2=2), format('1:(~d,~d,~d)(~d,~d,~d)~n', [X1,Y1,T1,X2,Y2,T2]).

%%chess(X1,Y1,T1), chess(X2,Y2,T2) # passive ==> (X1-X2=:=Y1-Y2;X1-X2=:=Y2-Y1) | member(T1,[0,1,2]), member(T2,[0,1,2]), (T1=1;T2=1;T1=2;T2=2), format('2:(~d,~d,~d)(~d,~d,~d)~n', [X1,Y1,T1,X2,Y2,T2]).

%%chess(X1,Y1,T1), chess(X2,Y2,T2) # passive ==> (X1=:=X2;Y1=:=Y2;X1-X2=:=Y1-Y2;X1-X2=:=Y2-Y1) | member(T1,[0,1,2]), member(T2,[0,1,2]), (T1=2;T2=2), format('3=', []).

%%conflict(X),conflict(Y) <=> conflict(Z), Z is X+Y.



%% chess(4,0,0), chess(6,1,0), chess(1,2,0), chess(3,3,1), chess(5,3,1), chess(3,6,1), chess(7,4,2), chess(0,5,2). 


%% Abduce its label
%% Abduce its rules
